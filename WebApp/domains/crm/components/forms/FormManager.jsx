import { showToast } from '../../../../shared/components/MESToast.js';
// Quotes Form Manager - Dynamic form configuration for quotes domain
// Refactored: Clean database format, no legacy conversion
import React from 'react';
import API from '../../../../shared/lib/api.js';
import { formsApi } from '../../services/forms-service.js';
import { FormBuilderCompact } from './formBuilder/FormBuilderCompact.js'

const { useState, useEffect, useCallback } = React;

// ==================== HELPER FUNCTIONS ====================

/**
 * Create field options via API
 * Options format: { label, optionCode? } from FieldEditor
 * API expects: { optionLabel, sortOrder } - optionCode is auto-generated by backend
 * @param {number} fieldId - Database field ID
 * @param {Array} options - Options array from FieldEditor
 */
async function createFieldOptions(fieldId, options) {
  if (!options || options.length === 0) return;
  
  for (let i = 0; i < options.length; i++) {
    const opt = options[i];
    // Handle both new format { label } and legacy string format
    const label = typeof opt === 'string' ? opt : (opt.label || opt.optionLabel || opt.value || opt);
    
    await formsApi.addOption(fieldId, {
      optionLabel: label,
      sortOrder: i
      // Note: optionCode is auto-generated by backend (FFOC-XXXX format)
      // Note: priceValue is deprecated - prices are in price_parameter_lookups
    });
  }
}

/**
 * Convert database field format to frontend format
 * DB: { id, fieldCode, fieldName, fieldType, options: [{optionCode, optionLabel}] }
 * Frontend: { id (fieldCode), dbId (veritabanÄ± ID), label, type, options: [{label, optionCode}] }
 */
function dbFieldToFrontend(field, index = 0) {
  return {
    id: field.fieldCode || field.id, // fieldCode yoksa id kullan (eski format uyumu)
    dbId: field.id, // QT-4/QT-7: VeritabanÄ± ID'si (display gÃ¼ncelleme iÃ§in gerekli)
    label: field.fieldName || field.label,
    type: field.fieldType || field.type,
    required: field.isRequired || field.required || false,
    placeholder: field.placeholder,
    defaultValue: field.defaultValue,
    helpText: field.helpText,
    display: {
      formOrder: field.sortOrder || index + 1,
      tableOrder: field.tableOrder || index + 1,
      showInTable: field.showInTable || false,
      showInFilter: field.showInFilter || false,
      filterOrder: field.filterOrder || 0
    },
    validation: field.validationRule ? JSON.parse(field.validationRule) : {},
    options: (field.options || []).map(opt => ({
      label: opt.optionLabel || opt.label,
      optionCode: opt.optionCode || null
    }))
  };
}

/**
 * Convert frontend field format to API format for saving
 * Frontend: { id, label, type, options: [{label, optionCode}] }
 * API: { fieldCode, fieldName, fieldType, ... }
 */
function frontendFieldToApi(field, index = 0) {
  return {
    id: field.id,
    label: field.label,
    type: field.type,
    required: field.required,
    placeholder: field.placeholder,
    defaultValue: field.defaultValue,
    helpText: field.helpText || null,
    sortOrder: field.display?.formOrder || index + 1,
    validationRule: field.validation ? JSON.stringify(field.validation) : null,
    // QT-4: Display settings
    showInTable: field.display?.showInTable || false,
    showInFilter: field.display?.showInFilter || false,
    tableOrder: field.display?.tableOrder || index + 1,
    filterOrder: field.display?.filterOrder || 0,
    options: field.options || []
  };
}

// ==================== COMPONENT ====================

function FormManager({ t, renderHeaderActions }) {
  const [formConfig, setFormConfig] = useState(null)
  const [isLoading, setIsLoading] = useState(true)
  const [templateId, setTemplateId] = useState(null)
  const [allTemplates, setAllTemplates] = useState([])
  const [activeTemplateId, setActiveTemplateId] = useState(null)
  const [currentTemplateId, setCurrentTemplateId] = useState(null)
  const [isNewDraftModalOpen, setIsNewDraftModalOpen] = useState(false)
  const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false)
  const [newDraftName, setNewDraftName] = useState('')
  const [isCurrentDraft, setIsCurrentDraft] = useState(false)
  const [hasChanges, setHasChanges] = useState(false)
  const [originalFields, setOriginalFields] = useState([])

  useEffect(() => {
    loadFormConfig()
    loadAllTemplates()
  }, [])

  async function loadFormConfig() {
    try {
      setIsLoading(true)
      
      // Get active template with fields
      const template = await formsApi.getActiveTemplate()
      
      console.log('ðŸ” FormManager - Loaded template:', template)
      
      if (template) {
        setTemplateId(template.id)
        setActiveTemplateId(template.id)
        setCurrentTemplateId(template.id)
        setIsCurrentDraft(false) // Active template is not a draft
        
        // Convert DB fields to frontend format
        const fields = (template.fields || []).map((field, idx) => dbFieldToFrontend(field, idx))
        const frontendConfig = {
          fields,
          settings: { 
            title: template.name, 
            description: template.description || '' 
          }
        }
        console.log('ðŸ”„ FormManager - Converted to frontend format:', frontendConfig)
        setFormConfig(frontendConfig)
        // Store original fields for change detection
        setOriginalFields(JSON.parse(JSON.stringify(fields)))
        setHasChanges(false)
      } else {
        console.warn('No active template found, creating default')
        showToast('Aktif form ÅŸablonu bulunamadÄ±', 'warning')
        setFormConfig({ fields: [] })
        setIsCurrentDraft(true) // No active = treat as draft
      }
      
    } catch (e) {
      console.error('Form config load error:', e)
      showToast('Form yapÄ±landÄ±rmasÄ± yÃ¼klenemedi!', 'error')
      setFormConfig({ fields: [] })
    } finally {
      setIsLoading(false)
    }
  }

  async function loadAllTemplates() {
    try {
      const templates = await formsApi.getTemplates()
      setAllTemplates(templates)
      console.log('ðŸ“š All templates loaded:', templates)
    } catch (e) {
      console.error('Failed to load templates:', e)
    }
  }

  async function createNewDraft() {
    try {
      if (!newDraftName || !newDraftName.trim()) {
        showToast('Form ismi gereklidir', 'error')
        return
      }

      const response = await formsApi.createTemplate({
        code: `QUOTE_FORM_${Date.now()}`,
        name: newDraftName.trim(),
        description: '',
        version: 1,
        isActive: false // New draft starts as inactive
      })

      // API returns { success: true, template: {...} }
      const newTemplate = response.template || response

      // Yeni taslaÄŸÄ± gÃ¶rÃ¼ntÃ¼le - name'i de formConfig'e ekle
      setCurrentTemplateId(newTemplate.id)
      setTemplateId(newTemplate.id)
      setFormConfig({ 
        fields: [],
        settings: { title: newTemplate.name, description: '' }
      })
      setIsCurrentDraft(true)
      
      // Template listesini gÃ¼ncelle
      await loadAllTemplates()
      
      setIsNewDraftModalOpen(false)
      setNewDraftName('')
      showToast(`Yeni taslak oluÅŸturuldu: ${newTemplate.name}`, 'success')
    } catch (e) {
      console.error('Failed to create draft:', e)
      showToast('Taslak oluÅŸturulamadÄ±: ' + e.message, 'error')
    }
  }

  async function switchToTemplate(selectedTemplateId) {
    try {
      const template = await formsApi.getTemplateWithFields(selectedTemplateId)
      
      setCurrentTemplateId(selectedTemplateId)
      setTemplateId(selectedTemplateId)
      setIsCurrentDraft(!template.isActive)
      
      // Convert DB fields to frontend format
      const fields = (template.fields || []).map((field, idx) => dbFieldToFrontend(field, idx))
      const frontendConfig = {
        fields,
        settings: { 
          title: template.name, 
          description: template.description || '' 
        }
      }
      setFormConfig(frontendConfig)
      // Store original fields for change detection
      setOriginalFields(JSON.parse(JSON.stringify(fields)))
      setHasChanges(false)
      
      setIsHistoryModalOpen(false)
      showToast(`${template.isActive ? 'Aktif form' : 'Taslak'} yÃ¼klendi: ${template.name}`, 'info')
    } catch (e) {
      console.error('Failed to switch template:', e)
      showToast('Taslak yÃ¼klenemedi: ' + e.message, 'error')
    }
  }

  // Handle fields change from FormBuilderCompact
  // QT-4: Display settings (showInTable, showInFilter) deÄŸiÅŸiklikleri hasChanges'i tetiklememeli
  const handleFieldsChange = useCallback((newFields) => {
    // Display ayarlarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rmadan Ã§Ä±kar
    const stripDisplaySettings = (fields) => {
      return fields.map(f => {
        const { display, ...rest } = f;
        // display iÃ§inden sadece formOrder'Ä± tut (versiyon etkileyen)
        return {
          ...rest,
          display: display ? { formOrder: display.formOrder } : undefined
        };
      });
    };
    
    const strippedNew = stripDisplaySettings(newFields);
    const strippedOriginal = stripDisplaySettings(originalFields);
    const changed = JSON.stringify(strippedNew) !== JSON.stringify(strippedOriginal);
    setHasChanges(changed);
  }, [originalFields]);

  // QT-4: Handle display settings change (showInTable, showInFilter, tableOrder, filterOrder)
  // Bu ayarlar anÄ±nda kaydedilir ve versiyon deÄŸiÅŸtirmez
  const handleDisplaySettingsChange = useCallback(async (fieldId, displaySettings) => {
    try {
      // fieldId = veritabanÄ± ID'si (FieldEditor'dan geliyor)
      await formsApi.updateFieldDisplay(fieldId, displaySettings);
      
      // Event dispatch - QuotesManager dinleyecek
      window.dispatchEvent(new CustomEvent('formDisplaySettingsChanged', {
        detail: {
          templateId: currentTemplateId,
          fieldId: fieldId,
          changes: displaySettings
        }
      }));
      
      showToast('GÃ¶rÃ¼ntÃ¼leme ayarlarÄ± gÃ¼ncellendi', 'success');
    } catch (error) {
      console.error('Display settings update error:', error);
      showToast('GÃ¼ncelleme hatasÄ±: ' + error.message, 'error');
    }
  }, [currentTemplateId]);

  // Revert changes to original state
  const handleRevertChanges = useCallback(() => {
    if (originalFields.length > 0 || formConfig) {
      const revertedConfig = {
        ...formConfig,
        fields: JSON.parse(JSON.stringify(originalFields))
      }
      setFormConfig(revertedConfig)
      setHasChanges(false)
      showToast('DeÄŸiÅŸiklikler geri alÄ±ndÄ±', 'info')
    }
  }, [originalFields, formConfig])

  // Save as draft (isActive=false)
  async function saveDraft(config) {
    try {
      console.log('ðŸ’¾ Saving as draft:', config)
      console.log('ðŸ’¾ isCurrentDraft:', isCurrentDraft, 'currentTemplateId:', currentTemplateId)
      
      // Extract template info from config.settings
      const templateName = config.settings?.title || `Taslak - ${new Date().toLocaleString('tr-TR')}`
      const templateDescription = config.settings?.description || ''
      
      // Convert frontend fields to API format
      const apiFields = (config.fields || []).map((field, idx) => frontendFieldToApi(field, idx))
      
      if (isCurrentDraft && currentTemplateId) {
        // Mevcut taslaÄŸÄ± gÃ¼ncelle (isActive=false kalÄ±r)
        await formsApi.updateTemplate(currentTemplateId, {
          name: templateName,
          description: templateDescription
        })
        
        // Delete existing fields and recreate
        const existingFields = await formsApi.getFields(currentTemplateId)
        for (const field of existingFields) {
          await formsApi.deleteField(field.id)
        }
        
        // Create new fields
        for (const field of apiFields) {
          const fieldResponse = await formsApi.createField({
            templateId: currentTemplateId,
            fieldCode: field.id,
            fieldName: field.label,
            fieldType: field.type,
            sortOrder: field.sortOrder || 0,
            isRequired: field.required || false,
            placeholder: field.placeholder,
            defaultValue: field.defaultValue,
            validationRule: field.validationRule,
            helpText: field.helpText || null,
            // QT-4: Display settings
            showInTable: field.showInTable || false,
            showInFilter: field.showInFilter || false,
            tableOrder: field.tableOrder || 0,
            filterOrder: field.filterOrder || 0
          })
          
          // API returns { success: true, field: {...}, id: ... }
          const createdField = fieldResponse.field || fieldResponse
          
          // Create field options if any (using helper for format normalization)
          await createFieldOptions(createdField.id || fieldResponse.id, field.options)
        }
        
        // Update original fields after save
        setOriginalFields(JSON.parse(JSON.stringify(config.fields || [])))
        setHasChanges(false)
        showToast('Taslak gÃ¼ncellendi', 'success')
      } else {
        // Aktif form aÃ§Ä±kken "TaslaÄŸÄ± Kaydet" = YENÄ° taslak oluÅŸtur
        const response = await formsApi.createTemplate({
          code: `QUOTE_FORM_${Date.now()}`,
          name: templateName,
          description: templateDescription,
          version: 1,
          isActive: false // Always save as draft
        })
        
        // API returns { success: true, template: {...} }
        const newTemplate = response.template || response
        
        // Create fields for new template
        for (const field of apiFields) {
          const fieldResponse = await formsApi.createField({
            templateId: newTemplate.id,
            fieldCode: field.id,
            fieldName: field.label,
            fieldType: field.type,
            sortOrder: field.sortOrder || 0,
            isRequired: field.required || false,
            placeholder: field.placeholder,
            defaultValue: field.defaultValue,
            validationRule: field.validationRule,
            helpText: field.helpText || null,
            // QT-4: Display settings
            showInTable: field.showInTable || false,
            showInFilter: field.showInFilter || false,
            tableOrder: field.tableOrder || 0,
            filterOrder: field.filterOrder || 0
          })
          
          // API returns { success: true, field: {...}, id: ... }
          const createdField = fieldResponse.field || fieldResponse
          
          // Create field options if any (using helper for format normalization)
          await createFieldOptions(createdField.id || fieldResponse.id, field.options)
        }
        
        setCurrentTemplateId(newTemplate.id)
        setTemplateId(newTemplate.id)
        setIsCurrentDraft(true)
        // Update original fields after save
        setOriginalFields(JSON.parse(JSON.stringify(config.fields || [])))
        setHasChanges(false)
        
        showToast('Yeni taslak oluÅŸturuldu', 'success')
      }
      
      await loadAllTemplates()
    } catch (e) {
      console.error('Draft save error:', e)
      showToast('Taslak kaydedilemedi: ' + e.message, 'error')
    }
  }

  // Activate template - saves and activates
  async function activateTemplate(config) {
    try {
      console.log('ðŸš€ Activating template:', config)
      console.log('ðŸš€ isCurrentDraft:', isCurrentDraft, 'currentTemplateId:', currentTemplateId)
      
      // Extract template info from config.settings
      const templateName = config.settings?.title || `Form v${allTemplates.length + 1}`
      const templateDescription = config.settings?.description || ''
      
      // Convert frontend fields to API format
      const apiFields = (config.fields || []).map((field, idx) => frontendFieldToApi(field, idx))
      let targetTemplateId = currentTemplateId
      
      if (isCurrentDraft && currentTemplateId) {
        // Taslak aÃ§Ä±k - Ã¶nce kaydet, sonra aktif et
        await formsApi.updateTemplate(currentTemplateId, {
          name: templateName,
          description: templateDescription
        })
        
        // Delete existing fields and recreate
        const existingFields = await formsApi.getFields(currentTemplateId)
        for (const field of existingFields) {
          await formsApi.deleteField(field.id)
        }
        
        // Create new fields
        for (const field of apiFields) {
          const fieldResponse = await formsApi.createField({
            templateId: currentTemplateId,
            fieldCode: field.id,
            fieldName: field.label,
            fieldType: field.type,
            sortOrder: field.sortOrder || 0,
            isRequired: field.required || false,
            placeholder: field.placeholder,
            defaultValue: field.defaultValue,
            validationRule: field.validationRule,
            helpText: field.helpText || null,
            // QT-4: Display settings
            showInTable: field.showInTable || false,
            showInFilter: field.showInFilter || false,
            tableOrder: field.tableOrder || 0,
            filterOrder: field.filterOrder || 0
          })
          
          // API returns { success: true, field: {...}, id: ... }
          const createdField = fieldResponse.field || fieldResponse
          
          // Create field options if any (using helper for format normalization)
          await createFieldOptions(createdField.id || fieldResponse.id, field.options)
        }
      } else {
        // Aktif form aÃ§Ä±k - YENÄ° kayÄ±t oluÅŸtur ve hemen aktif et
        const response = await formsApi.createTemplate({
          code: `QUOTE_FORM_${Date.now()}`,
          name: templateName,
          description: templateDescription,
          version: (allTemplates.length || 0) + 1,
          isActive: false // Ã–nce false, sonra activate edeceÄŸiz
        })
        
        // API returns { success: true, template: {...} }
        const newTemplate = response.template || response
        
        // Create fields for new template
        for (const field of apiFields) {
          const fieldResponse = await formsApi.createField({
            templateId: newTemplate.id,
            fieldCode: field.id,
            fieldName: field.label,
            fieldType: field.type,
            sortOrder: field.sortOrder || 0,
            isRequired: field.required || false,
            placeholder: field.placeholder,
            defaultValue: field.defaultValue,
            validationRule: field.validationRule,
            helpText: field.helpText || null,
            // QT-4: Display settings
            showInTable: field.showInTable || false,
            showInFilter: field.showInFilter || false,
            tableOrder: field.tableOrder || 0,
            filterOrder: field.filterOrder || 0
          })
          
          // API returns { success: true, field: {...}, id: ... }
          const createdField = fieldResponse.field || fieldResponse
          
          // Create field options if any (using helper for format normalization)
          await createFieldOptions(createdField.id || fieldResponse.id, field.options)
        }
        
        targetTemplateId = newTemplate.id
      }
      
      // Åžimdi bu template'i aktif et (diÄŸerlerini deaktif eder)
      await formsApi.activateTemplate(targetTemplateId)
      
      setCurrentTemplateId(targetTemplateId)
      setTemplateId(targetTemplateId)
      setActiveTemplateId(targetTemplateId)
      setIsCurrentDraft(false)
      // Update original fields after activate
      setOriginalFields(JSON.parse(JSON.stringify(config.fields || [])))
      setHasChanges(false)
      
      await loadAllTemplates()
      
      // Event dispatch - QuotesManager dinleyecek
      window.dispatchEvent(new CustomEvent('activeFormChanged', {
        detail: { templateId: targetTemplateId }
      }))
      
      showToast('Form aktif edildi!', 'success')
    } catch (e) {
      console.error('Activate error:', e)
      showToast('Form aktif edilemedi: ' + e.message, 'error')
    }
  }

  // Legacy switchActiveTemplate - for backward compatibility
  async function switchActiveTemplate() {
    try {
      console.log('ðŸ”„ Activating template:', currentTemplateId)
      await formsApi.activateTemplate(currentTemplateId)
      await loadAllTemplates()
      await loadFormConfig()
      setActiveTemplateId(currentTemplateId)
      setIsCurrentDraft(false)
      
      // Event dispatch - QuotesManager dinleyecek
      window.dispatchEvent(new CustomEvent('activeFormChanged', {
        detail: { templateId: currentTemplateId }
      }))
      
      showToast('Aktif form deÄŸiÅŸtirildi!', 'success')
    } catch (e) {
      console.error('Failed to activate template:', e)
      showToast('Form aktif edilemedi: ' + e.message, 'error')
    }
  }

  // Legacy saveFormConfig - replaced by saveDraft and activateTemplate
  // Kept for backward compatibility if needed
  /*
  async function saveFormConfig(config) {
    try {
      console.log('ðŸ’¾ Saving form config:', config)
      
      // Convert legacy format to PostgreSQL format
      const templateData = convertFromLegacyFormat(config)
      console.log('ðŸ“¦ Template data:', templateData)
      
      let currentTemplateId = templateId
      
      if (currentTemplateId) {
        // Update existing template
        await formsApi.updateTemplate(currentTemplateId, {
          name: templateData.name,
          description: templateData.description
        })
        
        // Delete existing fields and recreate (simple approach)
        const existingFields = await formsApi.getFields(currentTemplateId)
        for (const field of existingFields) {
          await formsApi.deleteField(field.id)
        }
      } else {
        // Create new template
        const newTemplate = await formsApi.createTemplate({
          code: `QUOTE_FORM_${Date.now()}`,
          name: templateData.name || 'Teklif Formu',
          description: templateData.description,
          version: 1,
          isActive: true
        })
        
        currentTemplateId = newTemplate.id
        setTemplateId(currentTemplateId)
      }
      
      // Create/recreate all fields
      console.log('ðŸ“ Creating fields:', templateData.fields)
      for (const field of templateData.fields) {
        console.log('ðŸ” Field to create:', {
          templateId: currentTemplateId,
          fieldCode: field.id,
          fieldName: field.label,
          fieldType: field.type,
          sortOrder: field.sortOrder,
          isRequired: field.required,
          placeholder: field.placeholder,
          defaultValue: field.defaultValue,
          validationRule: field.validationRule,
          helpText: field.helpText,
          showInTable: field.showInTable,
          showInFilter: field.showInFilter
        })
        
        const createdField = await formsApi.createField({
          templateId: currentTemplateId,
          fieldCode: field.id,
          fieldName: field.label,
          fieldType: field.type,
          sortOrder: field.sortOrder || 0,
          isRequired: field.required || false,
          placeholder: field.placeholder,
          defaultValue: field.defaultValue,
          validationRule: field.validationRule,
          helpText: field.helpText || null,
          // QT-4: Display settings
          showInTable: field.showInTable || false,
          showInFilter: field.showInFilter || false,
          tableOrder: field.tableOrder || 0,
          filterOrder: field.filterOrder || 0
        })
        
        console.log('âœ… Field created:', createdField)
        
        // Create field options if any (using helper for format normalization)
        await createFieldOptions(createdField.id, field.options)
      }
      
      showToast('Form yapÄ±landÄ±rmasÄ± kaydedildi!', 'success')
      
      // Reload to get updated data
      await loadFormConfig()
    } catch (e) {
      console.error('Form config save error:', e)
      showToast('Form yapÄ±landÄ±rmasÄ± kaydedilemedi: ' + e.message, 'error')
    }
  }
  */

  if (isLoading) {
    return React.createElement('div', { className: 'form-tab loading' },
      React.createElement('div', { style: { textAlign: 'center', padding: '40px' } },
        React.createElement('div', { className: 'spinner' }),
        React.createElement('p', null, t.settings_form_loading || 'Form yapÄ±landÄ±rmasÄ± yÃ¼kleniyor...')
      )
    )
  }

  return React.createElement(React.Fragment, null,
    React.createElement(FormBuilderCompact, {
      formConfig,
      onSave: saveDraft,
      onActivate: activateTemplate,
      onRevertChanges: handleRevertChanges,
      onFieldsChange: handleFieldsChange,
      onDisplaySettingsChange: handleDisplaySettingsChange, // QT-4: Display ayarlarÄ± iÃ§in ayrÄ± callback
      hasChanges,
      originalFields,
      isDarkMode: false,
      t,
      showToast,
      renderHeaderActions,
      // Versioning props
      allTemplates,
      activeTemplateId,
      currentTemplateId,
      isCurrentDraft,
      isNewDraftModalOpen,
      isHistoryModalOpen,
      newDraftName,
      onCreateDraft: createNewDraft,
      onSwitchTemplate: switchToTemplate,
      onActivateTemplate: switchActiveTemplate,
      onOpenNewDraftModal: () => setIsNewDraftModalOpen(true),
      onCloseNewDraftModal: () => setIsNewDraftModalOpen(false),
      onOpenHistoryModal: () => setIsHistoryModalOpen(true),
      onCloseHistoryModal: () => setIsHistoryModalOpen(false),
      onDraftNameChange: (e) => setNewDraftName(e.target.value)
    })
  )
}

export default FormManager